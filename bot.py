import logging
import datetime
from typing import Dict, List
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

from config import BOT_TOKEN, USER_ID, TIMEZONE, TASKS_SCHEDULE
from database import TaskDatabase
import utils

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class TaskAssistantBot:
    def __init__(self):
        self.db = TaskDatabase()
        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–æ—Å–∫–æ–≤—Å–∫–∏–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å
        self.moscow_tz = pytz.timezone('Europe/Moscow')
        self.scheduler = AsyncIOScheduler(timezone=self.moscow_tz)
        self.add_task_state: Dict[int, Dict] = {}
        self.setup_scheduler()
    
    def setup_scheduler(self):
        """–ë–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ (–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º)."""
        logger.info(f"APScheduler timezone: {self.scheduler.timezone}")
        for job in self.scheduler.get_jobs():
            try:
                next_run = getattr(job, 'next_run_time', None)
            except Exception:
                next_run = None
            logger.info(f"Job {job.id} next run: {next_run}")

    def schedule_reports_for_user(self, chat_id: int, user_id: int):
        daily_id = f'daily_report_{chat_id}'
        weekly_id = f'weekly_report_{chat_id}'
        self.scheduler.add_job(
            self.send_daily_report_v2,
            CronTrigger(hour=20, minute=0, timezone=self.moscow_tz),
            args=[chat_id, user_id],
            id=daily_id,
            replace_existing=True
        )
        self.scheduler.add_job(
            self.send_weekly_report_v2,
            CronTrigger(day_of_week=6, hour=20, minute=30, timezone=self.moscow_tz),
            args=[chat_id, user_id],
            id=weekly_id,
            replace_existing=True
        )

    def schedule_task_definition(self, chat_id: int, user_id: int, task_def: Dict):
        days: List[int] = task_def.get('days_list') or list(range(7))
        rh, rm = map(int, task_def['reminder_time'].split(':'))
        ch, cm = map(int, task_def['check_time'].split(':'))
        def_id = task_def['id']
        name = task_def['name']
        for day in days:
            r_job_id = f'v2_reminder_{chat_id}_{def_id}_{day}_{rh:02d}{rm:02d}'
            c_job_id = f'v2_check_{chat_id}_{def_id}_{day}_{ch:02d}{cm:02d}'
            self.scheduler.add_job(
                self.send_task_reminder_v2,
                CronTrigger(day_of_week=day, hour=rh, minute=rm, timezone=self.moscow_tz),
                args=[chat_id, user_id, def_id, name],
                id=r_job_id,
                replace_existing=True
            )
            self.scheduler.add_job(
                self.send_completion_check_v2,
                CronTrigger(day_of_week=day, hour=ch, minute=cm, timezone=self.moscow_tz),
                args=[chat_id, user_id, def_id, name],
                id=c_job_id,
                replace_existing=True
            )

    def schedule_all_for_user(self, chat_id: int, user_id: int):
        defs = self.db.list_task_definitions(user_id)
        for d in defs:
            self.schedule_task_definition(chat_id, user_id, d)
        self.schedule_reports_for_user(chat_id, user_id)
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /start"""
        chat_id = update.effective_chat.id
        username = update.effective_user.username
        user_id = self.db.upsert_user(chat_id, username)
        self.schedule_all_for_user(chat_id, user_id)
        
        welcome_text = """
ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∑–∞–¥–∞—á!

–î–æ–±–∞–≤—å—Ç–µ —Å–≤–æ–∏ –∑–∞–¥–∞—á–∏ –∏ –ø–æ–ª—É—á–∞–π—Ç–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.

üìä –û—Ç—á–µ—Ç—ã:
‚Ä¢ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç –≤ 20:00
‚Ä¢ –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –≤ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤ 20:30

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.
        """
        await update.message.reply_text(welcome_text)
        await update.message.reply_text("–î–æ–±–∞–≤—å—Ç–µ —Å–≤–æ—é –∑–∞–¥–∞—á—É –∫–æ–º–∞–Ω–¥–æ–π /addtask. –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–∏—Å–æ–∫: /mytasks")
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /help"""
        help_text = """
üìñ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:

/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
/addtask - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É (–¥–æ 10)
/cancel - –û—Ç–º–µ–Ω–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
/mytasks - –°–ø–∏—Å–æ–∫ –º–æ–∏—Ö –∑–∞–¥–∞—á
/today - –ü–æ–∫–∞–∑–∞—Ç—å –∑–∞–¥–∞—á–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
/stats - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞ —Å–µ–≥–æ–¥–Ω—è
/report - –ü–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç –∑–∞ —Å–µ–≥–æ–¥–Ω—è
 
üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:
/start_bot - –ó–∞–ø—É—Å—Ç–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
/stop_bot - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
        """
        await update.message.reply_text(help_text)
    
    async def send_task_reminder(self, task_type: str, task_name: str):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –∑–∞–¥–∞—á–µ"""
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            # –ê—Ç–æ–º–∞—Ä–Ω–æ –ø–æ–ª—É—á–∞–µ–º –ø—Ä–∞–≤–æ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–µ–π
            lock_acquired, _ = self.db.acquire_send_lock(task_type, today)
            if not lock_acquired:
                logger.info(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–ª—è {task_type} –Ω–∞ {today}")
                return
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
            message = f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!\n\nüìã –í—Ä–µ–º—è –¥–ª—è: {task_name}\nüïê {datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%H:%M')}"
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
            keyboard = [
                [InlineKeyboardButton("‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"quick_yes_{task_type}_{today}")],
                [InlineKeyboardButton("‚ùå –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"quick_no_{task_type}_{today}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ (–∑–¥–µ—Å—å –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å application.bot)
            # –≠—Ç–æ –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤ main —Ñ—É–Ω–∫—Ü–∏–∏
            await self.send_message_to_user(message, reply_markup)
            
            # –§–ª–∞–≥ already set –≤ acquire_send_lock
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {e}")
    
    async def send_task_reminder_v2(self, chat_id: int, user_id: int, task_def_id: int, task_name: str):
        """–ú–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ."""
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            lock_acquired, _ = self.db.acquire_send_lock_v2(user_id, task_def_id, today)
            if not lock_acquired:
                return
            message = f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!\n\nüìã –í—Ä–µ–º—è –¥–ª—è: {task_name}\nüïê {datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%H:%M')}"
            keyboard = [
                [InlineKeyboardButton("‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"v2_quick_yes_{task_def_id}_{today}")],
                [InlineKeyboardButton("‚ùå –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"v2_quick_no_{task_def_id}_{today}")]
            ]
            await self.send_message_to_chat(chat_id, message, InlineKeyboardMarkup(keyboard))
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è v2: {e}")
    
    async def send_completion_check(self, task_type: str, task_name: str):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏"""
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            
            # –ê—Ç–æ–º–∞—Ä–Ω–æ –ø–æ–ª—É—á–∞–µ–º –ø—Ä–∞–≤–æ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –ø—Ä–æ–≤–µ—Ä–∫–∏, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–µ–π
            lock_acquired, _ = self.db.acquire_check_lock(task_type, today)
            if not lock_acquired:
                logger.info(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è {task_type} –Ω–∞ {today}")
                return
            
            message = f"üîç –ö–æ–Ω—Ç—Ä–æ–ª—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è!\n\nüìã –ó–∞–¥–∞—á–∞: {task_name}\n‚è∞ –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏: {datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%H:%M')}\n\n–í—ã–ø–æ–ª–Ω–∏–ª–∏ –ª–∏ –≤—ã —ç—Ç—É –∑–∞–¥–∞—á—É?"
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ –î–∞, –≤—ã–ø–æ–ª–Ω–∏–ª", callback_data=f"check_yes_{task_type}_{today}")],
                [InlineKeyboardButton("‚ùå –ù–µ—Ç, –Ω–µ –≤—ã–ø–æ–ª–Ω–∏–ª", callback_data=f"check_no_{task_type}_{today}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await self.send_message_to_user(message, reply_markup)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}")
    
    async def send_completion_check_v2(self, chat_id: int, user_id: int, task_def_id: int, task_name: str):
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            lock_acquired, _ = self.db.acquire_check_lock_v2(user_id, task_def_id, today)
            if not lock_acquired:
                return
            message = f"üîç –ö–æ–Ω—Ç—Ä–æ–ª—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è!\n\nüìã –ó–∞–¥–∞—á–∞: {task_name}\n‚è∞ –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏: {datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%H:%M')}\n\n–í—ã–ø–æ–ª–Ω–∏–ª–∏ –ª–∏ –≤—ã —ç—Ç—É –∑–∞–¥–∞—á—É?"
            keyboard = [
                [InlineKeyboardButton("‚úÖ –î–∞, –≤—ã–ø–æ–ª–Ω–∏–ª", callback_data=f"v2_check_yes_{task_def_id}_{today}")],
                [InlineKeyboardButton("‚ùå –ù–µ—Ç, –Ω–µ –≤—ã–ø–æ–ª–Ω–∏–ª", callback_data=f"v2_check_no_{task_def_id}_{today}")]
            ]
            await self.send_message_to_chat(chat_id, message, InlineKeyboardMarkup(keyboard))
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ v2: {e}")
    
    async def send_daily_report(self):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç"""
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            stats = self.db.get_completion_stats(today, today)
            tasks = self.db.get_tasks_for_date(today)
            
            report = f"üìä –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç - {today}\n\n"
            report += f"üìà –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
            report += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
            report += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
            report += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}%\n\n"
            
            report += "üìã –î–µ—Ç–∞–ª–∏ –ø–æ –∑–∞–¥–∞—á–∞–º:\n"
            for task in tasks:
                status = "‚úÖ" if task['completed'] else "‚ùå"
                report += f"‚Ä¢ {task['task_type']}: {status}\n"
                if task.get('comment'):
                    report += f"   üìù {task['comment']}\n"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—á–µ—Ç
            self.db.save_report('daily', today, today, stats)
            
            await self.send_message_to_user(report)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞: {e}")
    
    async def send_daily_report_v2(self, chat_id: int, user_id: int):
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
            stats = self.db.get_completion_stats_by_user(user_id, today, today)
            tasks = self.db.get_tasks_for_date_by_user(user_id, today)
            defs = {d['id']: d for d in self.db.list_task_definitions(user_id)}
            report = f"üìä –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç - {today}\n\n"
            report += f"üìà –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
            report += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
            report += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
            report += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}%\n\n"
            report += "üìã –î–µ—Ç–∞–ª–∏ –ø–æ –∑–∞–¥–∞—á–∞–º:\n"
            for task in tasks:
                status = "‚úÖ" if task.get('completed') else "‚ùå"
                name = defs.get(task.get('task_def_id'), {}).get('name', f"#{task.get('task_def_id')}")
                report += f"‚Ä¢ {name}: {status}\n"
                if task.get('comment'):
                    report += f"   üìù {task['comment']}\n"
            self.db.save_report('daily', today, today, stats, user_id)
            await self.send_message_to_chat(chat_id, report)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞ v2: {e}")
    
    async def send_weekly_report(self):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç"""
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE))
            week_start = (today - datetime.timedelta(days=today.weekday())).strftime('%Y-%m-%d')
            week_end = today.strftime('%Y-%m-%d')
            
            stats = self.db.get_completion_stats(week_start, week_end)
            tasks = self.db.get_tasks_for_period(week_start, week_end)
            
            report = f"üìä –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç\n"
            report += f"üìÖ –ü–µ—Ä–∏–æ–¥: {week_start} - {week_end}\n\n"
            report += f"üìà –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
            report += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
            report += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
            report += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}%\n\n"
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–Ω—è–º
            daily_stats = {}
            for task in tasks:
                date = task['date']
                if date not in daily_stats:
                    daily_stats[date] = {'total': 0, 'completed': 0}
                daily_stats[date]['total'] += 1
                if task['completed']:
                    daily_stats[date]['completed'] += 1
            
            report += "üìÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–Ω—è–º:\n"
            for date in sorted(daily_stats.keys()):
                day_stats = daily_stats[date]
                rate = (day_stats['completed'] / day_stats['total'] * 100) if day_stats['total'] > 0 else 0
                report += f"‚Ä¢ {date}: {day_stats['completed']}/{day_stats['total']} ({rate:.1f}%)\n"

            # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∑–∞ –Ω–µ–¥–µ–ª—é
            comments = [t for t in tasks if t.get('comment')]
            if comments:
                report += "\nüìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏:\n"
                for t in comments:
                    report += f"‚Ä¢ {t['date']} {t['task_type']}: {t['comment']}\n"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—á–µ—Ç
            self.db.save_report('weekly', week_start, week_end, stats)
            
            await self.send_message_to_user(report)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞: {e}")
    
    async def send_weekly_report_v2(self, chat_id: int, user_id: int):
        try:
            today = datetime.datetime.now(pytz.timezone(TIMEZONE))
            week_start = (today - datetime.timedelta(days=today.weekday())).strftime('%Y-%m-%d')
            week_end = today.strftime('%Y-%m-%d')
            stats = self.db.get_completion_stats_by_user(user_id, week_start, week_end)
            tasks = self.db.get_tasks_for_period_by_user(user_id, week_start, week_end)
            defs = {d['id']: d for d in self.db.list_task_definitions(user_id)}
            report = f"üìä –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç\n"
            report += f"üìÖ –ü–µ—Ä–∏–æ–¥: {week_start} - {week_end}\n\n"
            report += f"üìà –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
            report += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
            report += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
            report += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}%\n\n"
            daily_stats = {}
            for task in tasks:
                date = task['date']
                if date not in daily_stats:
                    daily_stats[date] = {'total': 0, 'completed': 0}
                daily_stats[date]['total'] += 1
                if task.get('completed'):
                    daily_stats[date]['completed'] += 1
            report += "üìÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–Ω—è–º:\n"
            for date in sorted(daily_stats.keys()):
                day_stats = daily_stats[date]
                rate = (day_stats['completed'] / day_stats['total'] * 100) if day_stats['total'] > 0 else 0
                report += f"‚Ä¢ {date}: {day_stats['completed']}/{day_stats['total']} ({rate:.1f}%)\n"
            comments = [t for t in tasks if t.get('comment')]
            if comments:
                report += "\nüìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏:\n"
                for t in comments:
                    name = defs.get(t.get('task_def_id'), {}).get('name', f"#{t.get('task_def_id')}")
                    report += f"‚Ä¢ {t['date']} {name}: {t['comment']}\n"
            self.db.save_report('weekly', week_start, week_end, stats, user_id)
            await self.send_message_to_chat(chat_id, report)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞ v2: {e}")
    
    async def send_message_to_user(self, message: str, reply_markup=None):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        # –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –±—É–¥–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ main —Ñ—É–Ω–∫—Ü–∏–∏
        pass
    
    async def send_message_to_chat(self, chat_id: int, message: str, reply_markup=None):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —á–∞—Ç (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Ä–µ–∂–∏–º–∞)."""
        # –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –±—É–¥–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ main —Ñ—É–Ω–∫—Ü–∏–∏
        pass

    def build_days_keyboard(self, selected_days: List[int]) -> InlineKeyboardMarkup:
        days_names = ['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–í—Å']
        chosen = set(selected_days or [])
        rows = []
        for i in range(0, 7, 2):
            row = []
            for d in [i, i+1] if i+1 < 7 else [i]:
                label = ("‚úÖ " if d in chosen else "") + days_names[d]
                row.append(InlineKeyboardButton(label, callback_data=f"addtask_day_{d}"))
            rows.append(row)
        rows.append([
            InlineKeyboardButton("–ì–æ—Ç–æ–≤–æ", callback_data="addtask_days_done"),
            InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="addtask_cancel")
        ])
        return InlineKeyboardMarkup(rows)
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        
        if data.startswith('quick_') or data.startswith('check_'):
            parts = data.split('_')
            action = parts[1]  # yes –∏–ª–∏ no
            task_type = parts[2]
            date = parts[3]
            
            completed = action == 'yes'
            self.db.mark_task_completed(task_type, date, completed)
            
            status_emoji = "‚úÖ" if completed else "‚ùå"
            status_text = "–≤—ã–ø–æ–ª–Ω–µ–Ω–æ" if completed else "–Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ"
            
            await query.edit_message_text(
                f"{status_emoji} –ó–∞–¥–∞—á–∞ {task_type} –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ {status_text}",
                reply_markup=None
            )
            # –ï—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏–º –æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
            if completed:
                context.user_data['awaiting_comment'] = {"task_type": task_type, "date": date}
                skip_keyboard = InlineKeyboardMarkup(
                    [[InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=f"skip_comment_{task_type}_{date}")]]
                )
                await self.send_message_to_user(
                    "üìù –•–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –ø—Ä–∞–∫—Ç–∏–∫–µ? –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –æ—Ç–≤–µ—Ç.",
                    reply_markup=skip_keyboard
                )
            return

        if data.startswith('skip_comment_'):
            parts = data.split('_')
            task_type = parts[2]
            date = parts[3]
            awaiting = context.user_data.get('awaiting_comment')
            if awaiting and awaiting.get('task_type') == task_type and awaiting.get('date') == date:
                context.user_data.pop('awaiting_comment', None)
            await query.edit_message_text("‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø—Ä–æ–ø—É—â–µ–Ω.")
            return

        # ----- V2 callbacks -----
        if data.startswith('v2_quick_') or data.startswith('v2_check_'):
            parts = data.split('_')
            # v2_quick_yes_{defId}_{date}
            action = parts[2]
            def_id = int(parts[3])
            date = parts[4]
            completed = action == 'yes'
            chat_id = update.effective_chat.id
            user = self.db.get_user_by_chat_id(chat_id)
            if not user:
                return
            user_id = user['id']
            self.db.mark_task_completed_v2(user_id, def_id, date, completed)
            status_emoji = "‚úÖ" if completed else "‚ùå"
            status_text = "–≤—ã–ø–æ–ª–Ω–µ–Ω–æ" if completed else "–Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ"
            await query.edit_message_text(
                f"{status_emoji} –ó–∞–¥–∞—á–∞ #{def_id} –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ {status_text}",
                reply_markup=None
            )
            if completed:
                context.user_data['awaiting_comment_v2'] = {"def_id": def_id, "date": date}
                skip_keyboard = InlineKeyboardMarkup(
                    [[InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=f"v2_skip_comment_{def_id}_{date}")]]
                )
                await self.send_message_to_chat(
                    chat_id,
                    "üìù –•–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π? –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –æ—Ç–≤–µ—Ç.",
                    reply_markup=skip_keyboard
                )
            return

        if data.startswith('v2_skip_comment_'):
            parts = data.split('_')
            def_id = int(parts[3])
            date = parts[4]
            awaiting = context.user_data.get('awaiting_comment_v2')
            if awaiting and awaiting.get('def_id') == def_id and awaiting.get('date') == date:
                context.user_data.pop('awaiting_comment_v2', None)
            await query.edit_message_text("‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø—Ä–æ–ø—É—â–µ–Ω.")
            return

        # ----- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏: –≤—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç–∏ –∏ –¥–Ω–µ–π -----
        if data.startswith('addtask_freq_'):
            freq = data.split('_')[2]
            chat_id = update.effective_chat.id
            st = self.add_task_state.get(chat_id) or {}
            st['frequency'] = 'daily' if freq == 'daily' else 'weekly'
            self.add_task_state[chat_id] = st
            if st['frequency'] == 'daily':
                await query.edit_message_text("–í—ã –≤—ã–±—Ä–∞–ª–∏: –µ–∂–µ–¥–Ω–µ–≤–Ω–æ. –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM")
                st['awaiting'] = 'reminder_time'
            else:
                st.setdefault('days', [])
                await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–Ω–∏ –Ω–µ–¥–µ–ª–∏. –ù–∞–∂–∏–º–∞–π—Ç–µ, –∑–∞—Ç–µ–º '–ì–æ—Ç–æ–≤–æ'.", reply_markup=self.build_days_keyboard(st['days']))
            return

        if data.startswith('addtask_day_'):
            chat_id = update.effective_chat.id
            day = int(data.split('_')[2])
            st = self.add_task_state.get(chat_id) or {}
            chosen = set(st.get('days', []))
            if day in chosen:
                chosen.remove(day)
            else:
                chosen.add(day)
            st['days'] = sorted(chosen)
            self.add_task_state[chat_id] = st
            await query.edit_message_reply_markup(reply_markup=self.build_days_keyboard(st['days']))
            return

        if data == 'addtask_days_done':
            chat_id = update.effective_chat.id
            st = self.add_task_state.get(chat_id) or {}
            if not st.get('days'):
                await query.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –¥–µ–Ω—å", show_alert=True)
                return
            st['awaiting'] = 'reminder_time'
            await query.edit_message_text("–£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM")
            return

        if data == 'addtask_cancel':
            chat_id = update.effective_chat.id
            self.add_task_state.pop(chat_id, None)
            await query.edit_message_text("‚ùå –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ")
            return

    async def comment_message_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π: –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –º–∞—Å—Ç–µ—Ä –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á"""
        text = (update.message.text or '').strip()
        chat_id = update.effective_chat.id
        
        # 1) –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ v1
        awaiting = context.user_data.get('awaiting_comment')
        if awaiting:
            task_type = awaiting['task_type']
            date = awaiting['date']
            if not text:
                await update.message.reply_text("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø—É—Å—Ç. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.")
                return
            self.db.set_task_comment(task_type, date, text)
            context.user_data.pop('awaiting_comment', None)
            await update.message.reply_text("üíæ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –°–ø–∞—Å–∏–±–æ!")
            return

        # 2) –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ v2
        awaiting_v2 = context.user_data.get('awaiting_comment_v2')
        if awaiting_v2:
            user = self.db.get_user_by_chat_id(chat_id)
            if user:
                user_id = user['id']
                def_id = awaiting_v2['def_id']
                date_v2 = awaiting_v2['date']
                if text:
                    self.db.set_task_comment_v2(user_id, def_id, date_v2, text)
                    await update.message.reply_text("üíæ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –°–ø–∞—Å–∏–±–æ!")
                context.user_data.pop('awaiting_comment_v2', None)
                return

        # 3) –ú–∞—Å—Ç–µ—Ä –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á
        st = self.add_task_state.get(chat_id)
        if not st:
            return
        if st.get('step') == 'name':
            if not text:
                await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–µ–ø—É—Å—Ç–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")
                return
            st['name'] = text[:64]
            st['step'] = 'frequency'
            keyboard = [[
                InlineKeyboardButton("–ï–∂–µ–¥–Ω–µ–≤–Ω–æ", callback_data="addtask_freq_daily"),
                InlineKeyboardButton("–ü–æ –¥–Ω—è–º –Ω–µ–¥–µ–ª–∏", callback_data="addtask_freq_weekly")
            ], [
                InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="addtask_cancel")
            ]]
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å:", reply_markup=InlineKeyboardMarkup(keyboard))
            return
        awaiting_kind = st.get('awaiting')
        if awaiting_kind == 'reminder_time':
            if not utils.validate_time_format(text):
                await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –∫–∞–∫ HH:MM")
                return
            st['reminder_time'] = text
            st['awaiting'] = 'check_time'
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –∫–æ–Ω—Ç—Ä–æ–ª—è HH:MM")
            return
        if awaiting_kind == 'check_time':
            if not utils.validate_time_format(text):
                await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –∫–∞–∫ HH:MM")
                return
            st['check_time'] = text
            user = self.db.get_user_by_chat_id(chat_id)
            if not user:
                user_id = self.db.upsert_user(chat_id, update.effective_user.username)
            else:
                user_id = user['id']
            frequency = st.get('frequency') or 'daily'
            days = st.get('days') if frequency == 'weekly' else list(range(7))
            def_id = self.db.add_task_definition(user_id, st['name'], frequency, days or list(range(7)), st['reminder_time'], st['check_time'])
            # –ü–ª–∞–Ω–∏—Ä—É–µ–º
            saved_defs = self.db.list_task_definitions(user_id)
            target_def = next((d for d in saved_defs if d['id'] == def_id), None)
            if target_def:
                self.schedule_task_definition(chat_id, user_id, target_def)
            await update.message.reply_text("‚úÖ –ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞!")
            self.add_task_state.pop(chat_id, None)
            return
    
    async def today_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /today"""
        tz = pytz.timezone(TIMEZONE)
        now = datetime.datetime.now(tz)
        today_str = now.strftime('%Y-%m-%d')
        weekday = now.weekday()
        chat_id = update.effective_chat.id
        user = self.db.get_user_by_chat_id(chat_id)
        if not user:
            await update.message.reply_text("–ù–∞—á–Ω–∏—Ç–µ —Å /start")
            return
        user_id = user['id']
        defs = self.db.list_task_definitions(user_id)
        tasks_in_db = {t.get('task_def_id'): t for t in self.db.get_tasks_for_date_by_user(user_id, today_str)}
        scheduled_today = []
        for d in defs:
            days_list = d.get('days_list') or list(range(7))
            if weekday in days_list:
                scheduled_today.append((d['id'], d['name']))
        if not scheduled_today:
            await update.message.reply_text(f"üìÖ –ù–∞ —Å–µ–≥–æ–¥–Ω—è ({today_str}) –∑–∞–¥–∞—á –Ω–µ—Ç –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é.")
            return
        message = f"üìã –ó–∞–¥–∞—á–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({today_str}):\n\n"
        for def_id, display_name in scheduled_today:
            if def_id in tasks_in_db:
                status = "‚úÖ" if tasks_in_db[def_id].get('completed') else "‚è≥"
            else:
                status = "‚è≥"
            message += f"‚Ä¢ {display_name}: {status}\n"
        await update.message.reply_text(message)
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /stats"""
        chat_id = update.effective_chat.id
        user = self.db.get_user_by_chat_id(chat_id)
        if not user:
            await update.message.reply_text("–ù–∞—á–Ω–∏—Ç–µ —Å /start")
            return
        user_id = user['id']
        today = datetime.datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
        stats = self.db.get_completion_stats_by_user(user_id, today, today)
        message = f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:\n\n"
        message += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
        message += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
        message += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}%"
        await update.message.reply_text(message)

    async def report_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        chat_id = update.effective_chat.id
        user = self.db.get_user_by_chat_id(chat_id)
        if not user:
            await update.message.reply_text("–ù–∞—á–Ω–∏—Ç–µ —Å /start")
            return
        await self.send_daily_report_v2(chat_id, user['id'])

    async def addtask_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        chat_id = update.effective_chat.id
        user = self.db.get_user_by_chat_id(chat_id)
        if not user:
            user_id = self.db.upsert_user(chat_id, update.effective_user.username)
        else:
            user_id = user['id']
        if self.db.count_task_definitions(user_id) >= 10:
            await update.message.reply_text("–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞ 10 –∑–∞–¥–∞—á.")
            return
        self.add_task_state[chat_id] = {'user_id': user_id, 'step': 'name'}
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ú–µ–¥–∏—Ç–∞—Ü–∏—è'):")

    async def mytasks_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        chat_id = update.effective_chat.id
        user = self.db.get_user_by_chat_id(chat_id)
        if not user:
            await update.message.reply_text("–ù–∞—á–Ω–∏—Ç–µ —Å /start")
            return
        defs = self.db.list_task_definitions(user['id'])
        if not defs:
            await update.message.reply_text("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /addtask")
            return
        lines = ["–í–∞—à–∏ –∑–∞–¥–∞—á–∏:"]
        days_names = ['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–í—Å']
        for d in defs:
            freq = '–ï–∂–µ–¥–Ω–µ–≤–Ω–æ' if (d.get('frequency') == 'daily') else '–ü–æ –¥–Ω—è–º –Ω–µ–¥–µ–ª–∏'
            days = d.get('days_list') or list(range(7))
            days_str = ','.join(days_names[i] for i in days)
            lines.append(f"‚Ä¢ #{d['id']} {d['name']} ‚Äî {freq}, –¥–Ω–∏: {days_str}, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ {d['reminder_time']}, –∫–æ–Ω—Ç—Ä–æ–ª—å {d['check_time']}")
        await update.message.reply_text('\n'.join(lines))

    async def show_days_keyboard(self, chat_id: int):
        st = self.add_task_state.get(chat_id) or {}
        chosen = set(st.get('days', []))
        days_names = ['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–í—Å']
        rows = []
        for i in range(0, 7, 2):
            row = []
            for d in [i, i+1] if i+1 < 7 else [i]:
                label = ("‚úÖ " if d in chosen else "") + days_names[d]
                row.append(InlineKeyboardButton(label, callback_data=f"addtask_day_{d}"))
            rows.append(row)
        rows.append([InlineKeyboardButton("–ì–æ—Ç–æ–≤–æ", callback_data="addtask_days_done")])
        markup = InlineKeyboardMarkup(rows)
        await self.send_message_to_chat(chat_id, "–í—ã–±–µ—Ä–∏—Ç–µ –¥–Ω–∏ –Ω–µ–¥–µ–ª–∏:", markup)
    
    async def start_bot_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /start_bot"""
        if not self.scheduler.running:
            self.scheduler.start()
            await update.message.reply_text("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã.")
        else:
            await update.message.reply_text("ü§ñ –ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω.")
    
    async def stop_bot_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /stop_bot"""
        if self.scheduler.running:
            self.scheduler.shutdown()
            await update.message.reply_text("‚èπÔ∏è –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã.")
        else:
            await update.message.reply_text("‚èπÔ∏è –ë–æ—Ç —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞
bot_instance = None

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    global bot_instance
    
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
        return
    
    if not USER_ID:
        logger.error("USER_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
        return
    
    # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
    bot_instance = TaskAssistantBot()
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    application = Application.builder().token(BOT_TOKEN).build()
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞ –¥–ª—è –º–µ–Ω—é
    try:
        await application.bot.set_my_commands([
            BotCommand("start", "–ó–∞–ø—É—Å–∫ –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"),
            BotCommand("help", "–ü–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–∞–º"),
            BotCommand("addtask", "–î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É"),
            BotCommand("mytasks", "–ú–æ–∏ –∑–∞–¥–∞—á–∏"),
            BotCommand("today", "–ó–∞–¥–∞—á–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"),
            BotCommand("stats", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è"),
            BotCommand("report", "–û—Ç—á–µ—Ç –∑–∞ —Å–µ–≥–æ–¥–Ω—è"),
            BotCommand("start_bot", "–ó–∞–ø—É—Å—Ç–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
            BotCommand("stop_bot", "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        ])
    except Exception as e:
        logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞: {e}")
    
    # –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    async def send_message_to_user(message: str, reply_markup=None):
        try:
            await application.bot.send_message(
                chat_id=USER_ID,
                text=message,
                reply_markup=reply_markup
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
    
    bot_instance.send_message_to_user = send_message_to_user
    
    async def send_message_to_chat(chat_id: int, message: str, reply_markup=None):
        try:
            await application.bot.send_message(
                chat_id=chat_id,
                text=message,
                reply_markup=reply_markup
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
    bot_instance.send_message_to_chat = send_message_to_chat
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", bot_instance.start))
    application.add_handler(CommandHandler("help", bot_instance.help_command))
    application.add_handler(CommandHandler("today", bot_instance.today_command))
    application.add_handler(CommandHandler("stats", bot_instance.stats_command))
    application.add_handler(CommandHandler("report", bot_instance.report_command))
    application.add_handler(CommandHandler("start_bot", bot_instance.start_bot_command))
    application.add_handler(CommandHandler("stop_bot", bot_instance.stop_bot_command))
    application.add_handler(CommandHandler("addtask", bot_instance.addtask_command))
    application.add_handler(CommandHandler("mytasks", bot_instance.mytasks_command))
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫
    application.add_handler(CallbackQueryHandler(bot_instance.button_callback))
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∫–∞–∫ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot_instance.comment_message_handler))
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
    bot_instance.scheduler.start()
    
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        await application.initialize()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º polling
        await application.start()
        await application.updater.start_polling()
        
        logger.info("–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç!")
        
        # –ñ–¥–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, –ø–æ–∫–∞ –Ω–µ –ø–æ–ª—É—á–∏–º —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        import signal
        import asyncio
        
        shutting_down = False
        stop_event = asyncio.Event()
        
        def signal_handler():
            logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
            asyncio.create_task(shutdown())
        
        async def shutdown():
            nonlocal shutting_down
            if shutting_down:
                return
            shutting_down = True
            logger.info("–ù–∞—á–∏–Ω–∞–µ–º –æ—Å—Ç–∞–Ω–æ–≤–∫—É –±–æ—Ç–∞...")
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º polling —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –∑–∞–ø—É—â–µ–Ω
            try:
                if getattr(application, 'updater', None):
                    await application.updater.stop()
            except RuntimeError:
                # Updater —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
                pass
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ updater: {e}")
            
            await application.stop()
            await application.shutdown()
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
            if bot_instance.scheduler.running:
                logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞...")
                bot_instance.scheduler.shutdown()
            logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            # –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–∞–≤–Ω–æ–º—É —Ü–∏–∫–ª—É –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è
            try:
                stop_event.set()
            except Exception:
                pass
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
        for sig in [signal.SIGTERM, signal.SIGINT]:
            signal.signal(sig, lambda s, f: signal_handler())
        
        # –ñ–¥–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ
        # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è (—Å–∏–≥–Ω–∞–ª –æ—Ç shutdown)
        await stop_event.wait()
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –±–æ—Ç–∞: {e}")
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        if bot_instance.scheduler.running:
            logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞...")
            bot_instance.scheduler.shutdown()
        raise

# –£–±—Ä–∞–Ω–æ asyncio.run() –æ—Ç—Å—é–¥–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ —Å run.py
# if __name__ == '__main__':
#     import asyncio
#     asyncio.run(main())
